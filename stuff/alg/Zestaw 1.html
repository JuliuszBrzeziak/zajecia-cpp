<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="" lang=""><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Algorytmy i struktury danych I">
  <title>Zestaw 1</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="Zestaw%201_files/homework.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Zestaw 1</h1>
<p class="author">Algorytmy i struktury danych I</p>
</header>
<p><strong>Termin oddania: 08.11.2019</strong><br>
<strong>Termin ostateczny: 29.11.2019</strong></p>
<h2 id="listy-i-listy-posortowane">Listy i listy posortowane</h2>
<blockquote>
<p><strong>Lista</strong> (ang. <em>list</em>) to struktura danych, w 
której elementy są ułożone w porządku liniowym. Lista jest jedną z 
podstawowych reprezentacji zbiorów dynamicznych. Elementy mogą się 
powtarzać.<br>
<strong>Lista uporządkowana</strong> to lista, której elementy są uporządkowane niemalejąco.</p>
</blockquote>
<ul>
<li>Proszę zapoznać się z <a href="https://www.youtube.com/watch?v=YQs6IC-vgmo">prezentacją Bjarna Stroustrupa</a>, twórcą języka C++, dotyczącej różnicy w wydajności między implementacją tablicową i wskaźnikową listy.</li>
<li><a href="https://youtu.be/o8NPllzkFhE?t=858"><em>Taste of Linus Torvalds</em></a> - proszę zapoznać się z wywiadem z twórcą jądra <em>Linux</em> oraz systemu kontroli wersji <em>Git</em> na temat implementacji listy (14:20-16:20).</li>
</ul>
<p>Zadania w tym zestawie dotyczą implementacji tablicowej i wskaźnikowej list oraz pozornej przewadze tej drugiej.<br>
<em>Abstrakcyjny typ danych</em> jakim jest <strong>lista uporządkowana</strong> powinien realizować następujące operacje:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">// using position_t = node&lt;T&gt;*; // Typ pozycji w liście dla implementacji wskaźnikowej</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="co">// using position_t = int;      // int dla implementacji tablicowej i kursorowej</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">class</span> SortedList {</span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="dt">void</span> push(T x);        <span class="co">// Wstawia element 'x'</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>    T pop();               <span class="co">// Zwraca i usuwa pierwszy (najmniejszy) element</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    T erase(<span class="dt">position_t</span> i); <span class="co">// Usuwa element na pozycji 'i' i zwraca jego wartość</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="dt">position_t</span> find(T x);  <span class="co">// Zwraca pozycję elementu o wartości 'x' lub -1 gdy nie znaleziono</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="dt">int</span> size();            <span class="co">// Zwraca liczbę elementów w liście</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="dt">void</span> remove(T x);      <span class="co">// Usuwa wszystkie elementy równe 'x'</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="at">static</span> SortedList merge(<span class="at">const</span> SortedList&amp; a, <span class="at">const</span> SortedList&amp; b);</span>
<span id="cb1-13"><a href="#cb1-13"></a>                           <span class="co">// Scala dwie posortowane listy i zwraca posortowaną listę</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>    <span class="dt">void</span> unique();         <span class="co">// Usuwa sąsiadujące duplikaty</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>    <span class="dt">void</span> print();          <span class="co">// Wypisuje elementy listy (w porządku rosnącym)</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>};</span></code></pre></div>
<blockquote>
<p>Złożoność obliczeniowa programów powinna być <em>optymalna</em> dla danej implementacji. Dla klas szablonowych <em>deklaracje</em> i <em>definicje</em> muszą znajdować się w jednym pliku nagłówkowym.</p>
</blockquote>
<h3 id="zadanie-1.-implementacja-tablicowa-listy-uporządkowanej-sortedarraylist.hxx">Zadanie 1. Implementacja tablicowa listy uporządkowanej (<code>sortedArrayList.hxx</code>)</h3>
<p>Napisać klasę <strong>szablonową</strong> <code>SortedArrayList</code>, będącą implementacją tablicową listy uporządkowanej <code>SortedList</code>.</p>
<blockquote>
<p>Elementy tablicy przechowują jedynie wartości elementów. Warto użyć funkcji <code>std::lower_bound</code> (<a href="https://pl.wikipedia.org/wiki/Wyszukiwanie_binarne">wyszukiwanie binarne</a>). Wskaźniki są dwukierunkowymi iteratorami (<code>BidirectionalIterator</code>). Można przyjąć sztywny maksymalny rozmiar listy/tablicy. Nie używać klasy <code>std::vector</code>.</p>
</blockquote>
<h3 id="zadanie-2.-implementacja-wskaźnikowa-listy-uporządkowanej-sortedlinkedlist.hxx">Zadanie 2. Implementacja wskaźnikowa listy uporządkowanej (<code>sortedLinkedList.hxx</code>)</h3>
<p>Napisać klasę <strong>szablonową</strong> <code>SortedLinkedList</code>, będącą podwójnie wiązaną implementacją wskaźnikową listy uporządkowanej <code>SortedList</code>.<br>
Dodać konstruktor domyślny, który tworzy pusta listę. Klasa (zagnieżdżona) węzła <code>Node</code> przechowuje element typu <code>T</code> oraz wskaźniki do poprzedniego i następnego węzła (lub <code>nullptr</code> gdy jest to skrajny element listy).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">class</span> SortedLinkedList {    <span class="co">// Klasa listy</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="kw">struct</span> Node {       <span class="co">// Zagnieżdżona klasa węzła</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>        T x;            <span class="co">// Element przechowywany przez węzeł listy</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>        node* prev;     <span class="co">// Wskaźnik do poprzedniego węzła</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>        node* next;     <span class="co">// Wskaźnik do kolejnego węzła</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    };</span>
<span id="cb2-8"><a href="#cb2-8"></a>  </span>
<span id="cb2-9"><a href="#cb2-9"></a>    node* head;         <span class="co">// Wskaźnik do pierwszego węzła</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>    node* tail;         <span class="co">// Wskaźnik do ostatniego węzła</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="dt">int</span> size;           <span class="co">// Ew. rozmiar listy</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>};</span></code></pre></div>
<blockquote>
<p><strong>Wskazówka:</strong> W klasie <code>SortedLinkedList</code> wskaźniki na początek i koniec listy (odpowiednio <code>head</code> i <code>tail</code>) warto zastąpić obiektem typu <code>Node</code>. Wówczas jego pole <code>next</code> pełni rolę wskaźnika <code>head</code>, a pole <code>prev</code> pełni rolę wskaźnika <code>tail</code>, rozmiar listy można przechować w polu <code>x</code>.
 Taka konstrukcja upraszcza kod ponieważ pozwala na automatyczne 
uwzględnienie przypadków dodania elementu na początek, środek bądź 
koniec listy. O tym mówi Linus Torvalds w <a href="https://youtu.be/o8NPllzkFhE?t=858">wywiadzie</a>.</p>
</blockquote>
<blockquote>
<p>Dla chętnych: Zastanowić się jak zaimplementować listę dwukierunkową zapamiętując tylko <strong>jeden</strong> wskaźnik.</p>
</blockquote>
<h3 id="zadanie-3.-łączenie-list-merging.cxx">Zadanie 3. Łączenie list (<code>merging.cxx</code>)</h3>
<p><strong>Dane wejściowe</strong> składają się z czterech linii:</p>
<ol type="1">
<li>Liczba <span class="math inline"><em>l</em><sub>1</sub></span> oznaczająca liczbę elementów w pierwszej liście</li>
<li><span class="math inline"><em>l</em><sub>1</sub></span> liczb, posortowane elementy pierwszej listy</li>
<li>Liczba <span class="math inline"><em>l</em><sub>2</sub></span> oznaczająca liczbę elementów w drugiej liście</li>
<li><span class="math inline"><em>l</em><sub>2</sub></span> liczb, posortowane elementy drugiej listy</li>
</ol>
<p>Napisać programy, które:</p>
<ol type="1">
<li>Generuje przypadkowy zestaw danych wejściowych. Jako argument przyjmuje maksymalny rozmiar obu list (łącznie).</li>
<li>Wypisuje listę powstałą po scaleniu dwóch list z powtórzeniami, t.j. wypisać wszystkie jej elementy (posortowane)</li>
<li>Wypisuje listę powstałą po scaleniu dwóch list bez powtórzeń (posortowane)</li>
<li>Punkty 2. i 3. przeprowadzić dla klas <code>SortedArrayList</code>, <code>SortedLinkedList</code> i <code>std::list</code> (operacje <code>merge</code> i <code>unique</code>).<br>
Porównać wyniki.</li>
</ol>
<p><strong>Uwaga:</strong> Operacja łączenia list powinna mieć złożoność <span class="math inline"><em>O</em>(<em>n</em> + <em>m</em>)</span>, gdzie <span class="math inline"><em>n</em></span> i <span class="math inline"><em>m</em></span> to rozmiary list źródłowych.</p>
<blockquote>
<p>Program ma czytać dane ze standardowego wejścia (<code>std::cin</code>) i wypisywać wynik na standardowe wyjście (<code>std::cout</code>).<br>
Powinien działać w czasie liniowym od długości list.</p>
</blockquote>
<h3 id="zadanie-4.-wydajność-sortaddremove.cxx">Zadanie 4. Wydajność (<code>sortAddRemove.cxx</code>)</h3>
<p>Proszę zapoznać się z <a href="https://www.youtube.com/watch?v=YQs6IC-vgmo">prezentacją Bjarna Stroustrupa</a>,
 twórcą języka C++, dotyczącej różnicy w wydajności między implementacją
 tablicową i wskaźnikową listy. Powtórzyć eksperyment opisany w 
pierwszych <span class="math inline">40<em>s</em></span> prezentacji np. dla <span class="math inline"><em>n</em> = 50</span>k elementów i porównać czas wykonania zadania dla obu implementacji. To znaczy:</p>
<ul>
<li>dodać <span class="math inline"><em>n</em></span> liczb losowych do listy uporządkowanej (metoda <code>push()</code>)</li>
<li>usunąć <span class="math inline"><em>n</em></span> elementów podając losową pozycję. Pozycja musi być mniejsza od aktualnej liczby elementów (metoda <code>erase()</code>)</li>
<li>zmierzyć czas wykonania zadania dla <strong>kilku</strong> wartości <span class="math inline"><em>n</em></span> (najdłuższy pomiar powinien trwać co najmniej minutę, patrz wskazówki na końcu zestawu)</li>
<li>oszacować złożoność obliczeniową dodawania i usuwania <span class="math inline"><em>n</em></span> losowych elementów, porównać przewidywanie teoretyczne z pomiarami</li>
<li>wyjaśnić różnicę w wydajności pomiędzy implementacjami</li>
<li>zrobić wykres (np. używając programów <code>gnuplot</code>, <code>gnumeric</code>, <code>LibreOffice</code>)
 przedstawiający czas realizacji w funkcji rozmiaru danych i dopasować 
teoretyczny czas wykonania, odpowiedzi umieścić w pliku README</li>
</ul>
<h3 id="zadanie-5.-iteratory">Zadanie 5. Iteratory</h3>
<p>Napisać klasę <code>template&lt;typename T&gt; struct iterator</code> zagnieżdżoną wewnątrz właściwej klasy, która będzie <strong>iteratorem</strong> dwukierunkowym dla listy. W przypadku implementacji wskaźnikowej, <em>iterator</em> powinien przechowywać jedynie wskaźnik do węzła listy. Dla implementacji tablicowej, struktura <em>iteratora</em> jest nieco bardziej skomplikowana.</p>
<p>Przykład:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;        <span class="co">// Klasa szablonowa</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">class</span> SortedLinkedList {            <span class="co">// List przechowuje obiekty typu T</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="kw">struct</span> node;            <span class="co">// Zagnieżdzona klasa węzła</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="kw">struct</span> iterator;        <span class="co">// Zagnieżdzona klasa iteratora</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="kw">using</span> pointer = node*;  <span class="co">// Alias typu wskaźnik do węzła</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>    ...</span>
<span id="cb3-7"><a href="#cb3-7"></a>    iterator begin() { <span class="cf">return</span> iterator(head); }</span>
<span id="cb3-8"><a href="#cb3-8"></a>};</span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="kw">struct</span> SortedLinkedList&lt;T&gt;::iterator {</span>
<span id="cb3-12"><a href="#cb3-12"></a>    pointer ptr;            <span class="co">// Jedyne pole iteratora</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>    ...</span>
<span id="cb3-14"><a href="#cb3-14"></a>};</span></code></pre></div>
<p>Klasa <code>iterator</code> powinna spełniać warunki <a href="https://en.cppreference.com/w/cpp/iterator#C.2B.2B20_iterator_concepts">iteratora dwukierunkowego</a>. Zaimplementować operatory:</p>
<ul>
<li><code>++</code> - inkrementacji, zwraca <code>*this</code> czyli obiekt typu <code>iterator&amp;</code></li>
<li><code>--</code> - dekrementacji, zwraca <code>*this</code> czyli obiekt typu <code>iterator&amp;</code></li>
<li><code>*</code> - dereferencji, zwraca obiekt typu <code>T&amp;</code></li>
<li><code>==, !=</code> - porównania zwraca typ <code>bool</code></li>
</ul>
<p>Dodatkowo klasy implementujące listy muszą posiadać następujące metody:</p>
<ul>
<li><code>iterator begin()</code> - zwraca iterator do początku listy</li>
<li><code>iterator end()</code> - zwraca iterator do końca listy (<code>ptr == nullptr</code>)</li>
<li><code>iterator insert(iterator, const T&amp;)</code> - wstawia element przed elementem wskazywanym przez iterator</li>
<li><code>iterator erase(iterator)</code> - usuwa element wskazywany przez iterator i zwraca iterator do kolejnego elementu</li>
</ul>
<p>Prawidłowa implementacja powinna zapewniać poprawne działanie pętli <em>for-each</em>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="cf">for</span>(<span class="at">const</span> <span class="kw">auto</span>&amp; a : lista)</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="bu">std::</span>endl;</span></code></pre></div>
<p>Powyższą składnię należy wykorzystać w metodzie <code>print</code>.</p>
<p><strong>Uwaga:</strong> Standard <em>C++17</em> wycofał kilka elementów, które były w C++ od początku. Jednym z nich jest <code>std::iterator</code>.</p>
<h3 id="zadanie-6.-semantyka-przenoszenia">Zadanie 6. Semantyka przenoszenia</h3>
<p>Standard <em>C++11</em> wprowadza między innymi następujące nowe elementy - <em>r-wartości</em>, <em>semantyka przenoszenia</em>, <em>uniwersalne odwołania</em> i <em>doskonałe przekazywanie</em>. Zapoznać się z referencjami do r-wartości (ang. <em>r-value references</em>, &amp;&amp;), semantyką przenoszenia (<a href="http://en.cppreference.com/w/cpp/utility/move"><code>std::move</code></a>) (<a href="http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html">Alex Allain, <em>Move semantics and rvalue references in C++11</em></a>) oraz uniwersalnymi odwołaniami (ang. <em>universal references</em>) i doskonałym przekazywaniem (ang. <em>perfect forwarding</em>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><code>std::forward</code></a>) (<a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">Scott Meyers, <em>Universal References in C++11</em></a>).</p>
<p><em>R-wartości</em> wskazują obiekty podatne na operacje przenoszenia, na ogół odpowiadają tymczasowym obiektom np. zwracanym przez funkcje.<br>
<strong>Semantyka przenoszenia</strong> umożliwia zastąpienie kosztownych operacji kopiowania przez mniej kosztowne operacja przenoszenia.<br>
<strong>Doskonałe przekazywanie</strong> umożliwia szablonom funkcji przekazywanie argumentów z zachowaniem wartościowości (<em>r-wartość</em> czy <em>l-wartość</em>).</p>
<p>Szablony funkcji <code>std::move</code> i <code>std::forward</code> służą tylko do odpowiednio bezwarunkowego i warunkowego rzutowania. Funkcja <code>std::move</code> niczego nie przenosi, funkcja <code>std::forward</code> niczego nie niczego nie przekazuje. Funkcje te nie generują żadnego kodu wykonywalnego.</p>
<p><strong>Uwagi:</strong></p>
<ul>
<li>Odwołanie (referencja) do <em>r-wartości</em> jest <em>l-wartością</em>. Parametr funkcji zawsze jest <em>l-wartością</em>. Funkcja <code>std::move</code> zwraca odwołanie do <em>r-wartości</em>, ale wartości zwracane przez funkcję są <em>r-wartościami</em>!</li>
<li>To czy wyrażenie jest <em>l-wartością</em> czy <em>r-wartością</em> jest niezależne od typu.</li>
<li><em>R-wartości</em> pozwalają na semantykę przenoszenia oraz tworzenie konstruktorów przenoszących (<code>Foo(Foo&amp;&amp;)</code>) i przenoszących operatorów przypisania (<code>Foo&amp; operator=(Foo&amp;&amp;)</code>).</li>
<li>Operacje przenoszenia nie zawsze są tańsze od kopiowania i nie są tak tanie, jak oczekujemy.</li>
<li>Semantyka przenoszenia pozwala także tworzyć typy, które mogą być tylko przenoszone (np. <code>std::unique_ptr</code>, <code>std::future</code> i <code>std::thread</code>).</li>
<li><code>R-wartość</code> z cechą <code>const</code> nie może zostać przeniesiona, zostanie przekopiowana. Rzutowanie <code>std:move</code> nie gwarantuje, że obiekt będzie mógł być przeniesiony.</li>
<li>Symbol <code>&amp;&amp;</code> może oznaczać <em>odwołanie do r-wartości</em> <strong>lub</strong> <em>odwołanie uniwersalne</em>.</li>
</ul>
<p>Użyć powyższych technik np. w funkcji <code>push()</code>.</p>
<p>Przykład:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">class</span> SortedLinkedList {</span>
<span id="cb5-3"><a href="#cb5-3"></a>    ...</span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="kw">template</span>&lt;<span class="kw">typename</span> U&gt;</span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="dt">void</span> push(U&amp;&amp; obj) {</span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="co">// Tutaj U&amp;&amp; oznacza uniwersalne odwołanie, nie r-wartość</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span class="co">// Dla l-wartości, U = Typ&amp;, U&amp;&amp; jest referencją do l-wartości (Typ&amp;)</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>    <span class="co">// Dla r-wartości, U = Typ, U&amp;&amp; jest referencją do r-wartości (Typ&amp;&amp;)</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>        head = <span class="kw">new</span> node(<span class="bu">std::</span>forward&lt;U&gt;(obj), <span class="kw">nullptr</span>, head);   </span>
<span id="cb5-10"><a href="#cb5-10"></a>        <span class="co">// std::forward&lt;U&gt; zapewnia doskonałe przekazanie</span></span>
<span id="cb5-11"><a href="#cb5-11"></a>      ...</span>
<span id="cb5-12"><a href="#cb5-12"></a>    }</span>
<span id="cb5-13"><a href="#cb5-13"></a>    ...</span>
<span id="cb5-14"><a href="#cb5-14"></a>};</span></code></pre></div>
<h2 id="wskazówki">Wskazówki</h2>
<h3 id="potoki-strumienie-i-przekierowania">Potoki, strumienie i przekierowania</h3>
<p>Programy powinny czytać dane ze standardowego wejścia <code>stdin</code> (np. przy użyciu <code>scanf</code> lub <code>std::cin</code>) oraz zapisać wynik do standardowego wyjścia <code>stdout</code> (np. przy użyciu <code>printf</code> lub <code>std::cout</code>).
 Takie rozwiązanie jest bardzo uniwersalne, mechanizm przekierowania 
strumieni pozwala na łatwe wczytanie danych z pliku oraz zapis danych do
 pliku z poziomu linii komend (terminala/konsoli):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1"></a><span class="ex">./program.x</span> <span class="op">&gt;</span> output.txt        <span class="co"># Zapis danych wyjściowych do pliku "output.txt"</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="ex">./program.x</span> <span class="op">&lt;</span> input.txt         <span class="co"># Odczyt danych wejściowych z pliku "input.txt"</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="ex">./program.x</span> <span class="op">&lt;</span> input.txt <span class="op">&gt;</span> output.txt  <span class="co"># Odczyt danych z pliku "input.txt" i zapis do "output.txt"</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="ex">./program.x</span> <span class="op">&gt;&gt;</span> append.txt       <span class="co"># Dopisanie danych wyjściowych do pliku</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="ex">./program.x</span> <span class="op">2&gt;</span> error.txt        <span class="co"># Zapis standardowego wyjścia błędów do pliku</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="ex">./program1.x</span> <span class="kw">|</span> <span class="ex">./program2.x</span>     <span class="co"># Wyjście pierwszego programu staje się wejściem drugiego</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="ex">./program1.x</span> <span class="kw">|&amp;</span> <span class="ex">./program2.x</span>    <span class="co"># Przekierowuje stdout i stderr na wejście drugiego programu</span></span></code></pre></div>
<h3 id="wczytywanie-danych">Wczytywanie danych</h3>
<blockquote>
<p>Aby przyspieszyć korzystanie ze standardowego wejścia w C++ można wyłączyć synchronizację strumieni wejścia/wyjścia (<code>cin</code>, <code>cout</code>) z <code>stdio</code>. W tym celu należy na samym początku programu użyć <code>ios_base::sync_with_stdio(false)</code>.</p>
</blockquote>
<blockquote>
<p>Wypełnienie kontenera <code>std::vector</code> danymi ze standardowego wejścia:</p>
</blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="dt">int</span> x;</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v;</span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="cf">while</span>(<span class="bu">std::</span>cin &gt;&gt; x)</span>
<span id="cb7-5"><a href="#cb7-5"></a>  v.push_back(x);</span></code></pre></div>
<blockquote>
<p>Wersja w jednej linii</p>
</blockquote>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a>vector&lt;<span class="dt">int</span>&gt; v(<span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cin), <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;());</span></code></pre></div>
<h3 id="pomiar-czasu-wykonania">Pomiar czasu wykonania</h3>
<p>Do pomiaru czasu wykonania kodu można użyć funkcji <a href="http://en.cppreference.com/w/cpp/chrono">std::chrono::high_resolution_clock</a> (patrz wskazówki) oraz komendy <a href="http://man7.org/linux/man-pages/man1/time.1.html">time</a>. Szkic użycia klasy <a href="http://en.cppreference.com/w/cpp/chrono">std::chrono::high_resolution_clock</a>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="pp">#include </span><span class="im">&lt;chrono&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>...</span>
<span id="cb9-3"><a href="#cb9-3"></a>{</span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span class="kw">auto</span> start = <span class="bu">std::</span>chrono<span class="bu">::</span>high_resolution_clock<span class="bu">::</span>now();</span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="co">// fragment kodu, którego czas wykonania mierzymy</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>    <span class="kw">auto</span> end = <span class="bu">std::</span>chrono<span class="bu">::</span>high_resolution_clock<span class="bu">::</span>now();</span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="bu">std::</span>chrono<span class="bu">::</span>duration&lt;<span class="dt">double</span>&gt; elapsed = end - start;</span>
<span id="cb9-8"><a href="#cb9-8"></a>    <span class="bu">std::</span>cerr &lt;&lt; <span class="st">"Elapsed time[s] = "</span> &lt;&lt; elapsed.count() &lt;&lt; endl;</span>
<span id="cb9-9"><a href="#cb9-9"></a>}</span></code></pre></div>
<h3 id="poprawa-wydajności">Poprawa wydajności</h3>
<p>Aby wykorzystać optymalizację kodu przez kompilator <code>g++</code> pod daną architekturę warto użyć flag <code>-O3</code> (pełna optymalizacja czasowa) oraz <code>-march=native</code> (użycie instrukcji dostępnych na danym procesorze).</p>
<p>Proszę zapoznać się z następującymi funkcjami w standardowej bibliotece <em>C++11</em>, przydatnymi w implementacji algorytmów sortowania, które operują m.in. na strukturach danych <code>std::vector</code> i <code>std::array</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a>swap, iter_swap, min_element, lower_bound, rotate</span></code></pre></div>
<p>Ponieważ są one zoptymalizowane pod dana architekturę, np. używają instrukcji <em>AVX</em>, często są wydajniejsze od ręcznie napisanego kodu.</p>
<hr>
<p>Andrzej Görlich<br>
agoerlich@netmail.if.uj.edu.pl<br>
<a href="http://th.if.uj.edu.pl/~atg/ASD">http://th.if.uj.edu.pl/~atg/ASD</a></p>


</body></html>